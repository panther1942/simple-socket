一、 程序启动
1、扫包 根据Application及其子类的配置扫包并处理扫到的类文件
2、检查插件列表 根据启动顺序加载插件并执行
3、用户操作

二、 启动服务器/客户端
1、检查插件列表 根据启动顺序加载插件并执行
2、如果有交互插件 则在插件执行完成后将操作权交给用户

三、 服务器收到连接
1、检查插件列表 初始化socket连接属性
2、插件加载完成 等待客户端请求协商
3、该socket对象的操作权交给用户

四、 客户端连接服务器
1、检查插件列表 初始化socket连接属性
2、插件加载完成 执行协商部分
3、该socket对象的操作权交给用户

五、 收到消息
1、检查插件列表 根据启动顺序加载插件并解析收到的消息
2、检查服务列表 根据消息头执行对应的服务

六、 发送消息
1、检查插件列表 根据启动顺序加载插件并处理要发送的消息
2、socket对象发送消息

需要分离的组件
1、CLI
2、GZIP
3、RSA/AES

插件可以以AOP的形式加载进去
但必须写一个简单易用的方法加载插件
不至于每个插件都要去定义织入点和切面

需要一个任务列表机制
以实现无人值守的工作 例如发送文件
任务列表的机制将在socket对象获取操作权后执行

文件发送的机制需要修改
例如文件的绝对路径拿token来换
这就需要一个临时存储空间
显然C/S都需要 那么谁来实现这个功能 容器还是什么
让容器去做 spring也是用的ConcurrentHashMap

客户端能否多开 多开的话发送消息的机制如何处理
客户端和服务器能否同时启动 如果可以 发送消息的机制如何处理
发送消息优先是检查上游UID 如果上游UID不存在 则检查下游UID
如果都不存在 则抛出异常 NoSuchSocketUID

是否需要支持UDP 暂不考虑

插件列表就和服务列表一样用注解扫描 用ConcurrentHashMap存储
AOP改用Aspectj 换其他开发环境的时候记得安装ACJ环境就好

一定要处理异常 可以多定义几个异常类
注解很重要 尽量不要复用注解 不要都定义为Component 这样功能上就模糊不清
ServiceMapping 这个是定义到具体的方法了 类上必须有Component注解 可以通过value执行这个方法
    实际上就是为了模拟Controller 我在想这种用单例还是原型
    原型的话高并发内存开销估计不小
    单例的话如果一个任务执行时间过长 那么等待时间就会很长

SocketService 定义socket服务
SocketPlugin 定义socket插件